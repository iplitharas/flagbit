<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flagship Dashboard</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">

  <style>
    .flag-on { border-left: 5px solid #28a745; }
    .flag-off { border-left: 5px solid #dc3545; }
    .flag-card { transition: transform 0.15s, box-shadow 0.15s; }
    .flag-card:hover { transform: scale(1.02); box-shadow: 0px 8px 20px rgba(0,0,0,0.12); }
    .flag-header { display:flex; justify-content:space-between; align-items:center; gap:0.5rem; }
    .flag-footer { display:flex; justify-content:flex-end; gap:0.5rem; margin-top: .5rem; }
    .search-bar { max-width: 480px; min-width: 200px; }
    .muted-small { font-size:.85rem; color:#6c757d; }
  </style>
</head>
<body class="bg-light">

<!-- Navbar -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
  <div class="container-fluid">
    <a class="navbar-brand fw-bold" href="#">ðŸš© Flagship</a>
    <div class="collapse navbar-collapse">
      <ul class="navbar-nav ms-auto">
        <li class="nav-item"><a class="nav-link" href="https://github.com/your-org/flagship" target="_blank">GitHub</a></li>
        <li class="nav-item"><a class="nav-link" href="https://your-docs-url" target="_blank">Docs</a></li>
        <li class="nav-item"><a class="nav-link" href="#" target="_blank">About</a></li>
      </ul>
    </div>
  </div>
</nav>




<div class="container my-4">

  <!-- Search and Filters -->
  <div class="d-flex justify-content-between align-items-center mb-4 flex-wrap gap-3">
    <div class="input-group search-bar">
      <span class="input-group-text bg-white"><i class="bi bi-search"></i></span>
      <input type="search" id="filterName" class="form-control" placeholder="Search flags by name... (type to filter)">
    </div>

    <div style="min-width:150px;">
      <select id="filterValue" class="form-select">
        <option value="all">All values</option>
        <option value="true">ON</option>
        <option value="false">OFF</option>
      </select>
    </div>
  </div>

  <!-- Create Flag Accordion -->
  <div class="accordion mb-4" id="createAccordion">
    <div class="accordion-item">
      <h2 class="accordion-header">
        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseCreate">
          âž• Create New Flag
        </button>
      </h2>
      <div id="collapseCreate" class="accordion-collapse collapse" data-bs-parent="#createAccordion">
        <div class="accordion-body">
          <form id="createFlagForm" class="row g-3">
            <div class="col-md-3">
              <input type="text" id="flagName" class="form-control" placeholder="Flag name" required>
            </div>
            <div class="col-md-3">
              <input type="text" id="flagDesc" class="form-control" placeholder="Description">
            </div>
            <div class="col-md-2">
              <select id="flagValue" class="form-select">
                <option value="true">ON</option>
                <option value="false">OFF</option>
              </select>
            </div>
            <div class="col-md-2">
              <input type="date" id="flagExpiry" class="form-control">
              <div class="muted-small">Optional</div>
            </div>
            <div class="col-md-2">
              <button type="submit" class="btn btn-primary w-100">Create</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- Flags List -->
  <div id="flagsContainer" class="row g-3"></div>
</div>

<!-- Toast Container -->
<div class="position-fixed top-0 end-0 p-3" style="z-index: 1055">
  <div id="toastContainer"></div>
</div>

<!-- Update Modal -->
<div class="modal fade" id="updateModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <form id="updateFlagForm">
        <div class="modal-header">
          <h5 class="modal-title">Update Flag</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"> </button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="updateId">
          <div class="mb-3">
            <label class="form-label">Description</label>
            <input type="text" id="updateDesc" class="form-control">
          </div>
          <div class="mb-3">
            <label class="form-label">Value</label>
            <select id="updateValue" class="form-select">
              <option value="true">ON</option>
              <option value="false">OFF</option>
            </select>
          </div>
          <div class="mb-3">
            <label class="form-label">Expiry Date</label>
            <input type="date" id="updateExpiry" class="form-control">
            <div class="muted-small">Leave empty for no expiration</div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="submit" class="btn btn-primary">Save changes</button>
        </div>
      </form>
    </div>
  </div>
</div>




<!-- Bootstrap JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

<script>
  // CLIENT-SIDE CACHE
  const flags = [];

  // UTILS
  function showToast(message, type = "success") {
    const toastId = `toast-${Date.now()}`;
    const toastHTML = `
      <div id="${toastId}" class="toast align-items-center text-bg-${type} border-0 mb-2" role="alert">
        <div class="d-flex">
          <div class="toast-body">${message}</div>
          <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
        </div>
      </div>`;
    document.getElementById('toastContainer').insertAdjacentHTML('beforeend', toastHTML);
    const el = document.getElementById(toastId);
    new bootstrap.Toast(el, { delay: 2500 }).show();
    // Remove toast from DOM when hidden
    el.addEventListener('hidden.bs.toast', () => el.remove());
  }

  function formatDateDDMMYYYY(d) {
    if (!d) return '';
    const dt = new Date(d);
    const dd = String(dt.getDate()).padStart(2, '0');
    const mm = String(dt.getMonth() + 1).padStart(2, '0');
    const yyyy = dt.getFullYear();
    return `${dd}/${mm}/${yyyy}`;
  }

  async function fetchFlags() {
    try {
      const res = await fetch('/flags', { method: 'GET', headers: { 'Accept': 'application/json' }, credentials: 'same-origin' });
      if (!res.ok) {
        const txt = await res.text().catch(() => '');
        console.error('fetchFlags failed', res.status, res.statusText, txt);
        showToast('Failed to load flags', 'danger');
        return;
      }
      const data = await res.json();
      flags.length = 0;
      if (Array.isArray(data)) flags.push(...data);
      renderFlags();
    } catch (err) {
      console.error(err);
      showToast('Error fetching flags', 'danger');
    }
  }

  async function createFlagAPI(payload) {
    try {
      const res = await fetch('/flags', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify(payload),
      });
      if (!res.ok) {
        const body = await res.text().catch(() => '');
        showToast(`Create failed: ${res.status}`, 'danger');
        console.error('createFlag failed', res.status, res.statusText, body);
        return false;
      }
      showToast(`Flag "${payload.name}" created`, 'primary');
      // close create accordion
      bootstrap.Collapse.getOrCreateInstance(document.getElementById('collapseCreate')).hide();
      await fetchFlags();
      return true;
    } catch (err) {
      console.error(err);
      showToast('Error creating flag', 'danger');
      return false;
    }
  }

  // PATCH for updates (partial update)
  async function patchFlagAPI(id, updates) {
    try {
      const res = await fetch(`/flags/${encodeURIComponent(id)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify(updates),
      });
      if (!res.ok) {
        const body = await res.text().catch(() => '');
        console.error('patchFlag failed', res.status, res.statusText, body);
        showToast('Update failed', 'danger');
        return false;
      }
      showToast('Flag updated', 'info');
      await fetchFlags();
      return true;
    } catch (err) {
      console.error(err);
      showToast('Error updating flag', 'danger');
      return false;
    }
  }

  async function deleteFlagAPI(id) {
    try {
      const res = await fetch(`/flags/${encodeURIComponent(id)}`, {
        method: 'DELETE',
        credentials: 'same-origin',
      });
      if (!res.ok) {
        const body = await res.text().catch(() => '');
        console.error('deleteFlag failed', res.status, res.statusText, body);
        showToast('Delete failed', 'danger');
        return false;
      }
      showToast('Flag deleted', 'warning');
      await fetchFlags();
      return true;
    } catch (err) {
      console.error(err);
      showToast('Error deleting flag', 'danger');
      return false;
    }
  }

  async function toggleFlagAPI(id, value) {
    try {
      const res = await fetch(`/flags/${encodeURIComponent(id)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ value }),
      });
      if (!res.ok) {
        const body = await res.text().catch(() => '');
        console.error('toggleFlag failed', res.status, res.statusText, body);
        showToast('Toggle failed', 'danger');
        await fetchFlags();
        return false;
      }
      showToast(`Flag ${value ? 'ON' : 'OFF'}`, value ? 'success' : 'danger');
      await fetchFlags();
      return true;
    } catch (err) {
      console.error(err);
      showToast('Error toggling flag', 'danger');
      return false;
    }
  }

  // RENDERING all flags based on current filters

  function renderFlags() {
    const flagsContainer = document.getElementById('flagsContainer');
    flagsContainer.innerHTML = '';
    const now = new Date();
    const filterName = (document.getElementById('filterName').value || '').toLowerCase();
    const filterValue = document.getElementById('filterValue').value;

    // Filter + sort (optional sort by name)
    const visible = flags
      .filter(f => (f.name || '').toLowerCase().includes(filterName))
      .filter(f => (filterValue === 'all') || String(f.value) === filterValue)
      .sort((a,b) => (a.name || '').localeCompare(b.name || ''));

    visible.forEach(flag => {
      // compute expiry text and badge rules:
      let expiryText = 'No expiration';
      let expireBadgeHTML = '';
      let isExpired = false;

      if (flag.expiration_date) {
        const expDate = new Date(flag.expiration_date);
        if (isNaN(expDate.getTime())) {
          expiryText = 'Invalid date';
        } else {
          const diffMs = expDate - now;
          const diffDays = Math.ceil(diffMs / (1000*60*60*24));
          expiryText = formatDateDDMMYYYY(expDate);
          if (diffMs < 0) {
            // already expired
            isExpired = true;
            expireBadgeHTML = `<span class="badge bg-danger ms-2">Expired</span>`;
            expiryText = `Expired on ${formatDateDDMMYYYY(expDate)}`;
          } else if (diffDays <= 7) {
            // expires soon -> show badge (user requested badge only in this case)
            expireBadgeHTML = `<span class="badge bg-warning text-dark ms-2">âš  Expires in ${diffDays} day${diffDays>1 ? 's' : ''}</span>`;
            // expiryText remains only the date (no "(in X days)" appended per your request)
            // We keep the badge to indicate the urgency.
          } else {
            // > 7 days left -> only show date (no badge)
            // expiryText already set to date string
          }
        }
      }

      const cardCol = document.createElement('div');
      cardCol.className = 'col-md-4';

      cardCol.innerHTML = `
        <div class="card flag-card ${ flag.value ? 'flag-on' : 'flag-off'}">
          <div class="card-body">
            <div class="flag-header">
              <h5 class="card-title mb-0">${escapeHtml(flag.name)}</h5>
              <div class="form-check form-switch">
                <input class="form-check-input toggle-switch" type="checkbox" ${flag.value ? 'checked' : ''} ${isExpired ? 'disabled' : ''}>
              </div>
            </div>

            <p class="card-text mt-2">${escapeHtml(flag.desc)}</p>
            <p><strong>Status:</strong> ${flag.value ? 'ON' : 'OFF'}</p>
            <p class="text-muted mb-1">Created: ${flag.date_created ? formatDateDDMMYYYY(flag.date_created) : ''}</p>
            <p class="text-muted mb-1">Updated: ${flag.date_updated ? formatDateDDMMYYYY(flag.date_updated) : ''}</p>
            <p class="text-muted mb-1">Expiry:  ${flag.expiration_date ? formatDateDDMMYYYY(flag.expiration_date) : ''} ${expireBadgeHTML}</p>

            <div class="flag-footer">
              <button class="btn btn-sm btn-warning update-btn"><i class="bi bi-pencil-square"></i></button>
              <button class="btn btn-sm btn-outline-danger delete-btn"><i class="bi bi-trash"></i></button>
            </div>
          </div>
        </div>`;

      flagsContainer.appendChild(cardCol);

      // Attach handlers
      const toggleEl = cardCol.querySelector('.toggle-switch');
      toggleEl.addEventListener('change', async (e) => {
        // disable toggling if expired (extra guard)
        if (isExpired) {
          e.target.checked = false;
          showToast('Flag is expired and cannot be toggled', 'danger');
          return;
        }
        await toggleFlagAPI(flag.id, e.target.checked);
      });

      cardCol.querySelector('.delete-btn').addEventListener('click', async () => {
        if (!confirm(`Delete flag "${flag.name}"?`)) return;
        await deleteFlagAPI(flag.id);
      });

      cardCol.querySelector('.update-btn').addEventListener('click', () => {
        document.getElementById('updateId').value = flag.id;
        document.getElementById('updateDesc').value = flag.desc || '';
        document.getElementById('updateValue').value = flag.value ? 'true' : 'false';
        // set date input in yyyy-mm-dd for browsers
        document.getElementById('updateExpiry').value = flag.expiration_date ? (new Date(flag.expiration_date)).toISOString().split('T')[0] : '';
        new bootstrap.Modal(document.getElementById('updateModal')).show();
      });
    });

    // If no results:
    if (visible.length === 0) {
      flagsContainer.innerHTML = '<div class="col-12"><div class="alert alert-secondary">No flags found.</div></div>';
    }
  }

  // ESCAPE helper to avoid injecting text directly
  function escapeHtml(str) {
    return String(str)
      .replaceAll('&','&amp;')
      .replaceAll('<','&lt;')
      .replaceAll('>','&gt;')
      .replaceAll('"','&quot;')
      .replaceAll("'",'&#39;');
  }

  // FORM HANDLERS
  document.getElementById('createFlagForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const name = document.getElementById('flagName').value.trim();
    if (!name) { showToast('Flag name is required', 'danger'); return; }
    const payload = {
      name,
      desc: document.getElementById('flagDesc').value.trim() || null,
      value: document.getElementById('flagValue').value === 'true',
      expiration_date: document.getElementById('flagExpiry').value || null,
    };
    const ok = await createFlagAPI(payload);
    if (ok) {
      e.target.reset();
      document.getElementById('flagExpiry').value = '';
    }
  });

  document.getElementById('updateFlagForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const id = document.getElementById('updateId').value;
    if (!id) { showToast('Invalid flag id', 'danger'); return; }
    const updates = {
      desc: document.getElementById('updateDesc').value || null,
      value: document.getElementById('updateValue').value === 'true',
      expiration_date: document.getElementById('updateExpiry').value || null,
    };
    const ok = await patchFlagAPI(id, updates);
    if (ok) {
      bootstrap.Modal.getInstance(document.getElementById('updateModal')).hide();
    }
  });

  // Filters wiring (real-time)
  document.getElementById('filterName').addEventListener('input', debounce(renderFlags, 150));
  document.getElementById('filterValue').addEventListener('change', renderFlags);

  // small debounce
  function debounce(fn, wait) {
    let t;
    return function(...args) {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), wait);
    };
  }

  // INITIAL LOAD
  document.addEventListener('DOMContentLoaded', fetchFlags);
</script>
</body>
</html>
